<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Edgar Daniel">

<title>Isochrones calculator – Geospatial Analytics Lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-b53751a350365c71b6c909e95f209ed1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-22381ab97ffb8a420d3841344730e94d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Geospatial Analytics Lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/edgar-daniel-codes/geospatial-analytics-lab"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#isochrones" id="toc-isochrones" class="nav-link active" data-scroll-target="#isochrones">Isochrones</a></li>
  <li><a href="#the-algorithm" id="toc-the-algorithm" class="nav-link" data-scroll-target="#the-algorithm">The Algorithm</a>
  <ul class="collapse">
  <li><a href="#from-streets-to-corners" id="toc-from-streets-to-corners" class="nav-link" data-scroll-target="#from-streets-to-corners">From Streets to Corners</a></li>
  <li><a href="#comprehensive-search" id="toc-comprehensive-search" class="nav-link" data-scroll-target="#comprehensive-search">Comprehensive search</a></li>
  <li><a href="#simulation-assumptions" id="toc-simulation-assumptions" class="nav-link" data-scroll-target="#simulation-assumptions">Simulation assumptions</a></li>
  </ul></li>
  <li><a href="#experiments" id="toc-experiments" class="nav-link" data-scroll-target="#experiments">Experiments</a>
  <ul class="collapse">
  <li><a href="#data-preparation" id="toc-data-preparation" class="nav-link" data-scroll-target="#data-preparation">Data preparation</a></li>
  <li><a href="#execution" id="toc-execution" class="nav-link" data-scroll-target="#execution">Execution</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Isochrones calculator</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Edgar Daniel </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="isochrones" class="level1">
<h1>Isochrones</h1>
<p>In geospatial analysis, one of the most important issues is identifying objects of interest that are within range of a given point. Think of all the cell phones that can be reached by an antenna, all the medical centers around a point in the city, and all the competitors near a store. For most of these problems, the most immediate solution is to define the range from a point in terms of distance. It is usually assumed to be Euclidean, but care must be taken because in geospatial analysis we work with projections.</p>
<p>Even ignoring the caveats regarding distances and projections, the problem lies in the fact that the space being analyzed is not uniform: nature presents geographical features, societies carry out infrastructure projects that modify the distribution of spaces, and cities and living spaces are irregular.</p>
<p>In addition, when we carry out reach exercises, time is a constraint. It is not the same to say that there are five health centers within a five-kilometer radius as it is to say that they can be reached in less than T minutes. Thus, we can define the isochrone as follows:</p>
<blockquote class="blockquote">
<p>Def. An isochrone <span class="math inline">\(I(x,t,Tt,Ht) \in \mathbb{R}^2\)</span> is the area or envelope of the set of routes that can be reached from point <span class="math inline">\(x\)</span> in less than <span class="math inline">\(t\)</span> minutes (or any unit of time measurement) for a type of transport <span class="math inline">\(Tt\)</span> within a defined time frame <span class="math inline">\(Ht\)</span>.</p>
</blockquote>
<p>Although, in general, due to computational cost or lack of information, fixed conditions <span class="math inline">\(T_t\)</span> and <span class="math inline">\(H_t\)</span> are assumed, assumptions must always be specified.</p>
<p>Below is an example of a range radius for a 15-minute drive isochrone in Mexico City (average, OSM API, very optimistic arrivals!).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/isocrhrone_example.png" class="img-fluid figure-img"></p>
<figcaption>Isochrones</figcaption>
</figure>
</div>
<p>This irregularity is what makes it necessary to take isochrones into account when studying range from a fixed point.</p>
<p>There are many complexities involved in dealing with isochrones, some of which are:</p>
<pre><code>- Heavy dependence on transportation vehicles.
- The time of day when the journey is made. 
- Infrastructure and sensitivity to events (accidents).
- Route adaptability and travel efficiency.</code></pre>
<p>However, their wide range of applications and importance in industry and research make it worthwhile to find algorithms and processes to estimate isochrones more accurately.</p>
</section>
<section id="the-algorithm" class="level1">
<h1>The Algorithm</h1>
<p>In practice, depending on the conditions and requirements of the problem (e.g., calculation accuracy, uniqueness, batch evaluation of isochrones, or multiple queries in short periods of time), a trade-off can be made between calculation accuracy and algorithm complexity. In this case, the aim is to generate intuition with a didactic approach to the problem of calculating isochrones. In subsequent exercises, other more efficient algorithms are reviewed, such as bounded Dijkstra or variants of A*.</p>
<p>The algorithm used is based on a DFS (Search First Depth), i.e., starting from the corner of origin, the algorithm iteratively explores all possible trajectories from that point. Since the goal is to find all possible routes in a given time, we move forward even if we cannot complete the route to the other corner. As long as there is time to travel the routes from a node, we move forward, even if it is not possible to complete them to the other corner.</p>
<p>Once all possible routes have been found, the geometric objects representing each trajectory are reconstructed and joined together in the same polygon. Next, a convex polygon operation is performed to obtain the coverage area with these routes and, finally, all possible routes within the coverage area are “restored” as possible routes, returning the SF objects in geodetic coordinates (lat, lon).</p>
<p>Below is a more comprehensive step-by-step guide on how the isochrone calculator was developed.</p>
<section id="from-streets-to-corners" class="level3">
<h3 class="anchored" data-anchor-id="from-streets-to-corners">From Streets to Corners</h3>
<p><strong>From streets to corners.</strong> As a starting point, we take an SHP file containing the lines of streets or roads that are considered accessible by our means of transport (in this case, pedestrian crossings). From this file, the corners are obtained in order to generate a network whose nodes (corners) are the points towards which we move and in which the edges are the connection of corners through the streets. In this case, the weight between edges is the time in seconds required to move from one vertex to another if they are connected.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/corners_example.png" class="img-fluid figure-img"></p>
<figcaption>Streets and corners as a network</figcaption>
</figure>
</div>
<p><strong>Initialization.</strong> Since we have a fixed starting point, <span class="math inline">\(x\)</span>, calculating all routes is inefficient, as the starting restriction allows us to start from there iteratively. We identify, without loss of generality, one of the corners as the starting point.</p>
<p>From here, we identify the points adjacent to the starting point along with their corresponding time cost, based on the weight of the streets determined by their length and the average speed of movement assigned to the algorithm.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_start_point.png" class="img-fluid figure-img"></p>
<figcaption>Initial point selection</figcaption>
</figure>
</div>
<p>Starting from the initial point, the st_buffer function is used to determine a circle with a radius of 5 m which, by intersecting with the street structure, identifies which streets are adjacent to the point itself. This operation is repeated with the segments to determine which corners and vertices are adjacent.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_adj_sp.png" class="img-fluid figure-img"></p>
<figcaption>Starting point adjacency</figcaption>
</figure>
</div>
<p>Here we have the first sub-paths.</p>
</section>
<section id="comprehensive-search" class="level3">
<h3 class="anchored" data-anchor-id="comprehensive-search">Comprehensive search</h3>
<p>If we isolate this subprocess and view it as a particular step, once we identify the point of interest (previously, the starting point) and its corresponding adjacencies, we can begin to construct a series of paths within our reach. In the following diagram, we can see how the subnetwork can then be considered as a tree from which we can explore the different options, updating the time budget and the list of nodes traversed so far with each decision.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_streets_to_tree.png" class="img-fluid figure-img"></p>
<figcaption>Diagram of step in the algorithm</figcaption>
</figure>
</div>
<p>If we exclude corners and streets already traveled (we do not want cycles in our paths), we can repeat this step iteratively as long as we have time available, thus adding consecutive nodes and generating a series of paths whose origin node is the starting point.</p>
<p>If the next adjacent node to be explored requires traveling along a street that takes longer than the available time, we decide to advance fractionally along the node until the available time runs out, thus creating a new node and “synthetic” edges, and the exploration is completed.</p>
<p>In this way, the loop is completed with a series of paths. Below is an example of the paths generated from the starting point:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_all_paths.png" class="img-fluid figure-img"></p>
<figcaption>Generated paths after running the loop</figcaption>
</figure>
</div>
<p>Finally, for the vast majority of applications, the aim is to obtain coverage. Therefore, based on these paths, a concave envelope polygon with smoothing is generated to cover the paths and generate the polygon considered to be the desired isochrone.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_area_cob.png" class="img-fluid figure-img"></p>
<figcaption>coverage area (proposed isochrone)</figcaption>
</figure>
</div>
</section>
<section id="simulation-assumptions" class="level2">
<h2 class="anchored" data-anchor-id="simulation-assumptions">Simulation assumptions</h2>
<p>In addition to assumptions about people’s walking speed, in order to perform a more realistic simulation, the algorithm includes waiting and “traffic” parameters. In other words, let’s look at the following diagram:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/crossroads.png" class="img-fluid figure-img"></p>
<figcaption>Street crossing diagram</figcaption>
</figure>
</div>
<p>We assume that if a path is passable on foot, it is also passable by bicycle.</p>
<p>We also assume that streets are two-way for pedestrians and bicycles.</p>
<p>As we can see, even when walking, especially in an urban area, we are forced to wait for the traffic light to change. Even on pedestrian-only streets, the presence of other people forces us to take these waiting times into account. On the one hand, there is the probability of encountering a red light, and on the other, the waiting time in seconds until it changes. This generates more realistic data. We have included this logic in each of the nodes (corners).</p>
</section>
</section>
<section id="experiments" class="level1">
<h1>Experiments</h1>
<blockquote class="blockquote">
<p>Question: How far from my house can I get by bike?</p>
</blockquote>
<p>Imagine you are a young office worker living in the south-central part of Mexico City. Every day you drive to and from work during rush hour. Mobility apps are very expensive, and you see many people riding bikes while you wait for the traffic light to turn green.</p>
<p>Before going online and buying a bike, you need to solve the following problem: you want to write code to simulate the distance you can actually travel. You will only change your mode of transportation if important places are within a 30-minute radius of your home; otherwise, you will continue to drive.</p>
<p>Therefore, the problem you want to solve is the following: how long does it take to travel 30 minutes by bike from my starting point (my home)?</p>
<p><strong>Problem statement</strong>:</p>
<blockquote class="blockquote">
<p>Given a shapefile of streets and a starting point, build an algorithm that calculates the isochrone in walking or biking distance for a given time and average speed.</p>
</blockquote>
<section id="data-preparation" class="level2">
<h2 class="anchored" data-anchor-id="data-preparation">Data preparation</h2>
<p>The following approach was used to prepare the data: using INEGI’s 2020 Geostatistical Framework, the Mexico City street file was filtered by the corresponding municipality. Based on this filter, a self-intersection was applied to obtain the corners corresponding to the municipality’s roads.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Data ---------------------------------------------------------------------</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Lines and streets from the point of interest</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>shp_streets <span class="ot">&lt;-</span> <span class="fu">st_read</span>(<span class="fu">paste0</span>(RAW_DATA, SHP_DIRECTORY,SHP_FILE_C)) <span class="sc">|&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(CVE_MUN <span class="sc">==</span> <span class="st">'014'</span>) <span class="sc">|&gt;</span> </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_transform</span>(<span class="at">crs =</span> CRS_MX)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># We get the corners from LINESTRING </span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>corners_sf <span class="ot">&lt;-</span> <span class="fu">st_intersection</span>(shp_streets) <span class="sc">|&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">st_geometry_type</span>(geometry) <span class="sc">==</span> <span class="st">"POINT"</span>) <span class="sc">|&gt;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(origins, geometry)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>corners_sf <span class="ot">&lt;-</span> corners_sf[<span class="sc">!</span><span class="fu">duplicated</span>(<span class="fu">st_as_binary</span>(corners_sf<span class="sc">$</span>geometry)), ] <span class="sc">|&gt;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">id_node =</span> <span class="fu">row_number</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We define our starting point in Mexico City as the following address: <a href="https://maps.app.goo.gl/p2SqWT23DZ66zDmX6">Dirección</a>.</p>
<p>A time budget of 30 minutes will be set, and the average cycling speed will be assumed to be 4 meters per second.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Execution  -----------------------------------------------------------------</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Starting Point </span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># https://maps.app.goo.gl/CnuKBE7yScWgANmp8</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>lat <span class="ot">&lt;-</span> <span class="fl">19.39798481495679</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>lon <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fl">99.1615400498479</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Maximum duration of trajectories in seconds </span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>T_segs <span class="ot">&lt;-</span> <span class="dv">30</span><span class="sc">*</span><span class="dv">60</span> </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>VEL_MPS <span class="ot">&lt;-</span> <span class="dv">4</span> <span class="co"># Average velocity in metter per second</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>TWT_IND <span class="ot">&lt;-</span> <span class="cn">TRUE</span> <span class="co"># Indicator if there are waiting times </span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>TRAFFIC_WT <span class="ot">&lt;-</span> <span class="dv">120</span> <span class="co"># Witing time in seconds </span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>TWT_PROB <span class="ot">&lt;-</span> <span class="fl">0.1</span> <span class="co"># Probability of waiting, wait for green lights</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>POINT_TOLERANCE_M <span class="ot">&lt;-</span> <span class="dv">150</span> <span class="co"># tolerance to find corner from point (mts)</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>ADJ_TOLERANCE_M <span class="ot">&lt;-</span> <span class="dv">3</span> <span class="co"># node-edge adjacency tolerance (mts)</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>ADJE_TOLERANCE_M <span class="ot">&lt;-</span> <span class="dv">3</span> <span class="co"># tolerance for edge-vertex adjacency (mts) </span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>DISPLAY <span class="ot">&lt;-</span> <span class="cn">TRUE</span> <span class="co"># Display map</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>ECHO <span class="ot">&lt;-</span> <span class="cn">FALSE</span> <span class="co"># Print simulation status </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="execution" class="level2">
<h2 class="anchored" data-anchor-id="execution">Execution</h2>
<p>Given the past parameters, we execute the simulation. Getting the following results:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>isoc <span class="ot">&lt;-</span> <span class="fu">calculate_isochrone</span>(lat,lon,T_segs,shp_streets,corners_sf</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                         , VEL_MPS</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                         , TWT_IND, TRAFFIC_WT,TWT_PROB</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                         , POINT_TOLERANCE_M, ADJ_TOLERANCE_M, ADJE_TOLERANCE_M</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                         , DISPLAY</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                         , ECHO</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                         , CRS_MX)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(isoc<span class="sc">$</span>mapa)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="fu">st_write</span>(isoc<span class="sc">$</span>paths_isochrone,<span class="fu">paste0</span>(<span class="st">"./data/sample/"</span>, <span class="st">"/iso_paths.geojson"</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>         ,<span class="at">layer =</span> <span class="st">"iso_paths.geojson"</span> )</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="fu">st_write</span>(isoc<span class="sc">$</span>hull_isochrone,<span class="fu">paste0</span>(<span class="st">"./data/sample/"</span>, <span class="st">"/iso_hull.geojson"</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>         ,<span class="at">layer =</span> <span class="st">"iso_hull.geojson"</span> )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_final_map.png" class="img-fluid figure-img"></p>
<figcaption>Resulting Map</figcaption>
</figure>
</div>
<p>In the map above, we can see in light gray the streets of interest (movement restriction) corresponding to the Miguel Hidalgo, Benito Juárez, and Coyoacán municipalities. In black are the reachable roads contained in the isochrone, and in blue is the isochrone itself. The starting point is in green, and the goal is to reach the blue point (office).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_se_points.png" class="img-fluid figure-img"></p>
<figcaption>Points of origin and destination</figcaption>
</figure>
</div>
<p>As we can see in the previous image, the blue point is within our isochrone, allowing us to conclude that we can indeed complete our journey in at least 30 minutes under the mobility assumptions that were made.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>