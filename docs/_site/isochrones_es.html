<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Edgar Daniel">

<title>Isochrones calculator – Geospatial Analytics Lab</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-b53751a350365c71b6c909e95f209ed1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-22381ab97ffb8a420d3841344730e94d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Geospatial Analytics Lab</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/edgar-daniel-codes/geospatial-analytics-lab"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#isócronas" id="toc-isócronas" class="nav-link active" data-scroll-target="#isócronas">Isócronas</a></li>
  <li><a href="#el-algoritmo" id="toc-el-algoritmo" class="nav-link" data-scroll-target="#el-algoritmo">El Algoritmo</a>
  <ul class="collapse">
  <li><a href="#inicialización" id="toc-inicialización" class="nav-link" data-scroll-target="#inicialización">Inicialización</a></li>
  <li><a href="#búsqueda-exhaustiva." id="toc-búsqueda-exhaustiva." class="nav-link" data-scroll-target="#búsqueda-exhaustiva.">Búsqueda exhaustiva.</a></li>
  <li><a href="#supuestos-de-simulación" id="toc-supuestos-de-simulación" class="nav-link" data-scroll-target="#supuestos-de-simulación">Supuestos de Simulación</a></li>
  </ul></li>
  <li><a href="#experimentos" id="toc-experimentos" class="nav-link" data-scroll-target="#experimentos">Experimentos</a>
  <ul class="collapse">
  <li><a href="#preparación-de-los-datos" id="toc-preparación-de-los-datos" class="nav-link" data-scroll-target="#preparación-de-los-datos">Preparación de los datos</a></li>
  <li><a href="#ejecución" id="toc-ejecución" class="nav-link" data-scroll-target="#ejecución">Ejecución</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Isochrones calculator</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Edgar Daniel </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="isócronas" class="level1">
<h1>Isócronas</h1>
<p>En el análisis geoespacial, una de las cuestiones más importantes es identificar los objetos de interés que se encuentran dentro del alcance de un punto determinado. Piensa en todos los teléfonos móviles a los que llega una antena, en todos los centros médicos que hay alrededor de un punto de la ciudad y en todos los competidores cercanos a una tienda. Para la mayoría de estos problemas, la solución más inmediata consiste en definir el alcance desde un punto en términos de distancia. Normalmente se supone que es euclidiano, pero hay que tener cuidado porque en el análisis geoespacial trabajamos con proyecciones.</p>
<p>Incluso ignorando las salvedades relativas a las distancias y las proyecciones, el problema radica en que el espacio que se analiza no es uniforme: la naturaleza presenta accidentes geográficos, las sociedades llevan a cabo proyectos de infraestructura que modifican la distribución de los espacios y las ciudades y los espacios habitacionales son irregulares.</p>
<p>A esto hay que añadir que, cuando realizamos ejercicios de alcance, una restricción es el tiempo. No es lo mismo decir que hay cinco centros de salud en un radio de cinco kilómetros que decir que se pueden alcanzar en menos de T minutos. Así pues, podemos definir la isocrona de la siguiente forma:</p>
<blockquote class="blockquote">
<p>Def. Una isocrona <span class="math inline">\(I(x,t,Tt,Ht) \in \mathbb{R}^2\)</span>, es el área o envolvente del conjunto de rutas que se pueden alcanzar desde el punto <span class="math inline">\(x\)</span> en menos de <span class="math inline">\(t\)</span> minutos (o cualquier unidad de medida del tiempo) para un tipo de transporte <span class="math inline">\(Tt\)</span> en un horario definifo <span class="math inline">\(Ht\)</span></p>
</blockquote>
<p>Aunque, por lo general, debido al coste computacional o a la falta de información, se asumen condiciones <span class="math inline">\(T_t\)</span> y <span class="math inline">\(H_t\)</span> fijas, siempre se deben especificar los supuestos.</p>
<p>A continuación se muestra un ejemplo de radio de alcance para una isocrona de 15 minutos en coche en la Ciudad de México (promedio, API de OSM, ¡llegadas muy optimistas!).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/isocrhrone_example.png" class="img-fluid figure-img"></p>
<figcaption>Isócrona</figcaption>
</figure>
</div>
<p>Esta irregularidad es la que hace necesario tener en cuenta las isocronas en el estudio del alcance desde un punto fijo.</p>
<p>Las complejidades que surgen al lidiar con isocrónas son muchas, algunas de las cuales son:</p>
<pre><code>- Fuerte dependencia de los vehículos de transporte. 
- El momento del día en que se realiza el trayecto. 
- Infraestructura y sensibilidad a eventos (accidentes). 
- Adaptabilidad de la ruta y eficiencia de los recorridos. </code></pre>
<p>No obstante, su gran cantidad de aplicaciones e importancia en la industria y la investigación hacen que valga la pena encontrar algoritmos y procesos para estimar isocronas de forma más precisa.</p>
</section>
<section id="el-algoritmo" class="level1">
<h1>El Algoritmo</h1>
<p>En la práctica, y dependiendo de las condiciones y necesidades del problema (por ejemplo, exactitud en el cálculo, unicidad, evaluación de isocrónas por lotes o múltiples consultas en cortos periodos de tiempo), se puede hacer un trade-off entre la precisión del cálculo y la complejidad del algoritmo. En este caso, se pretende generar una intuición con un enfoque didáctico del problema del cálculo de isocrónas. En ejercicios posteriores, se revisan otros algoritmos más eficientes, como Dijkstra acotado o variantes de A*.</p>
<p>El algoritmo que se utiliza se basa en un DFS (Search First Depth), es decir, partiendo de la esquina de origen, el algoritmo explora iterativamente todas las trayectorias posibles desde ese punto. Como el objetivo es encontrar todas las rutas posibles en un tiempo determinado, avanzamos incluso si no podemos completar la ruta hasta la otra esquina. Siempre que haya tiempo para recorrer las rutas desde un nodo, se avanza, aunque no sea posible completarlas hasta la otra esquina.</p>
<p>Una vez encontradas todas las rutas posibles, se reconstruyen los objetos geométricos que representan cada trayectoria y se unen en el mismo polígono. A continuación, se realiza una operación de polígono convexo para obtener el área de cobertura con estas rutas y, por último, se «restablecen» todas las rutas posibles dentro del área de cobertura como rutas posibles, devolviendo los objetos SF en coordenadas geodésicas (lat, lon).</p>
<p>A continuación, se ofrece una guía paso a paso más completa sobre cómo se desarrolló la calculadora de isócronas.</p>
<section id="inicialización" class="level3">
<h3 class="anchored" data-anchor-id="inicialización">Inicialización</h3>
<p><strong>De calles a esquinas.</strong> Como punto de partida, se toma un archivo SHP que contenga las líneas de las calles o vías que se consideran accesibles por nuestro medio de transporte (en este caso, pasos peatonales). A partir de este archivo, se obtienen las esquinas con la finalidad de generar una red cuyos nodos (esquinas) son los puntos hacia los que avanzamos y en los que las aristas son la conexión de esquinas a través de las calles. En este caso, el peso entre aristas es el tiempo en segundos que se requiere para pasar de un vértice a otro si están conectados.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/corners_example.png" class="img-fluid figure-img"></p>
<figcaption>Calles y esquinas como nodos en una red</figcaption>
</figure>
</div>
<p><strong>Inicialización.</strong> Como se tiene un punto de partida fijo, <span class="math inline">\(x\)</span>, calcular todas las rutas es poco eficiente, pues la restricción de partida nos permite partir de ahí de manera iterativa. Identificamos, sin pérdida de generalidad, una de las esquinas que se tienen como punto de partida.</p>
<p>A partir de aquí, identificamos los puntos adyacentes al punto de partida junto con su coste de tiempo correspondiente, basado en el peso de las calles determinado por su longitud y la velocidad de movimiento promedio asignada al algoritmo.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_start_point.png" class="img-fluid figure-img"></p>
<figcaption>Selección de punto inicial</figcaption>
</figure>
</div>
<p>A partir del punto inicial, se utiliza la función st_buffer para determinar un círculo de radio 5 m que, por medio de la intersección con la estructura de las calles, identifique cuáles de estas son adyacentes al punto en sí. Esta operación se repite con los segmentos para determinar qué esquinas y vértices son adyacentes.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_adj_sp.png" class="img-fluid figure-img"></p>
<figcaption>Adjacencias al punto inicial</figcaption>
</figure>
</div>
<p>A partir de esto se identifican los primeros subcaminos.</p>
</section>
<section id="búsqueda-exhaustiva." class="level3">
<h3 class="anchored" data-anchor-id="búsqueda-exhaustiva.">Búsqueda exhaustiva.</h3>
<p>Si aislamos este subproceso y lo vemos como un paso en particular, una vez que identificamos el punto de interés (anteriormente, el punto de partida) y sus correspondientes adjacencias, podemos comenzar a construir una serie de caminos a nuestro alcance. En el siguiente diagrama podemos ver cómo la subred se puede considerar entonces como un árbol del que podemos explorar las diferentes opciones, actualizando en cada decisión el presupuesto de tiempo y la lista de nodos recorridos hasta el momento.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_streets_to_tree.png" class="img-fluid figure-img"></p>
<figcaption>Diagrama de paso en el algoritmo</figcaption>
</figure>
</div>
<p>Si excluimos las esquinas y calles ya recorridas (no queremos ciclos en nuestros caminos), podemos repetir este paso de manera iterativa siempre que tengamos tiempo disponible, agregando así los nodos consecutivos y generando una serie de caminos cuyo nodo de origen es el punto de partida.</p>
<p>En el caso de que el siguiente nodo adyacente que se va a explorar requiera recorrer una calle cuyo tiempo necesario sea mayor que el presupuesto disponible, se decide avanzar sobre el nodo de manera fraccional hasta que se agote el tiempo disponible, creando así un nuevo nodo y aristas «sintéticos», y se finaliza la exploración.</p>
<p>De esta manera, se finaliza el bucle con una serie de caminos. A continuación, se muestra un ejemplo de los caminos generados a partir del punto de partida:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_all_paths.png" class="img-fluid figure-img"></p>
<figcaption>Caminos generados por el bucle</figcaption>
</figure>
</div>
<p>Finalmente, para la gran mayoría de las aplicaciones, se pretende obtener una cobertura, por lo que, a partir de estos caminos, se genera un polígono envolvente cóncavo con suavizado que permita cubrir los caminos y generar el polígono considerado como la isócrona buscada.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_area_cob.png" class="img-fluid figure-img"></p>
<figcaption>área de cobertura (Isócrona propuesta)</figcaption>
</figure>
</div>
</section>
<section id="supuestos-de-simulación" class="level2">
<h2 class="anchored" data-anchor-id="supuestos-de-simulación">Supuestos de Simulación</h2>
<p>Además de las suposiciones sobre la velocidad de marcha de las personas, con el fin de realizar una simulación más realista, el algoritmo incluye parámetros de espera y «tráfico». En otras palabras, veamos el siguiente esquema:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/crossroads.png" class="img-fluid figure-img"></p>
<figcaption>Diagrama de cruce de calles</figcaption>
</figure>
</div>
<p>Suponemos que si un camino es transitable a pie, también lo es para bicicletas.</p>
<p>Asimismo, suponemos que las calles son de doble sentido para peatones y bicicletas.</p>
<p>Como podemos ver, incluso cuando caminamos, especialmente en una zona urbana, nos vemos obligados a esperar a que cambie el semáforo. Incluso en las calles exclusivas para peatones, la presencia de otras personas nos obliga a tener en cuenta estos tiempos de espera. Por un lado, está la probabilidad de encontrarnos con un semáforo en rojo y, por otro, el tiempo de espera en segundos hasta que cambie. Esto genera datos más realistas. Hemos incluido esta lógica en cada uno de los nodos (esquinas).</p>
</section>
</section>
<section id="experimentos" class="level1">
<h1>Experimentos</h1>
<blockquote class="blockquote">
<p>Pregunta: ¿A qué distancia de mi casa puedo llegar en bicicleta?</p>
</blockquote>
<p>Imagina que eres un joven oficinista que vive en la zona centro-sur de Ciudad de México. Todos los días vas y vuelves del trabajo en coche en hora punta. Las aplicaciones de movilidad son muy caras y ves a mucha gente en bicicleta mientras esperas a que se ponga en verde el semáforo.</p>
<p>Antes de conectarte a internet y comprar una bicicleta, debes resolver el siguiente problema: quieres escribir un código para simular la distancia que realmente puedes recorrer. Solo cambiarás de medio de transporte si los lugares importantes se encuentran en un radio de 30 minutos desde tu casa; de lo contrario, seguirás conduciendo.</p>
<p>Por lo tanto, el problema que quieres resolver es el siguiente: ¿cuánto tiempo se tarda en recorrer 30 minutos en bicicleta desde mi punto de partida (mi casa)?</p>
<p><strong>Planteamiento del problema</strong>:</p>
<blockquote class="blockquote">
<p>Dado un archivo shapefile de calles y un punto de partida, construir un algoritmo que calcule la isócrona en distancia a pie o en bicicleta para un tiempo y una velocidad media determinados.</p>
</blockquote>
<section id="preparación-de-los-datos" class="level2">
<h2 class="anchored" data-anchor-id="preparación-de-los-datos">Preparación de los datos</h2>
<p>Para preparar los datos se utilizó el siguiente enfoque: utilizando el Marco Geoestadístico 2020 del INEGI, se filtró el archivo de calles de la Ciudad de México por el municipio correspondiente. A partir de este filtro, se aplicó una autointersección para obtener las esquinas correspondientes a las vías del municipio.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Data ---------------------------------------------------------------------</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Lines and streets from the point of interest</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>shp_streets <span class="ot">&lt;-</span> <span class="fu">st_read</span>(<span class="fu">paste0</span>(RAW_DATA, SHP_DIRECTORY,SHP_FILE_C)) <span class="sc">|&gt;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(CVE_MUN <span class="sc">==</span> <span class="st">'014'</span>) <span class="sc">|&gt;</span> </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">st_transform</span>(<span class="at">crs =</span> CRS_MX)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="co"># We get the corners from LINESTRING </span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>corners_sf <span class="ot">&lt;-</span> <span class="fu">st_intersection</span>(shp_streets) <span class="sc">|&gt;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(<span class="fu">st_geometry_type</span>(geometry) <span class="sc">==</span> <span class="st">"POINT"</span>) <span class="sc">|&gt;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(origins, geometry)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>corners_sf <span class="ot">&lt;-</span> corners_sf[<span class="sc">!</span><span class="fu">duplicated</span>(<span class="fu">st_as_binary</span>(corners_sf<span class="sc">$</span>geometry)), ] <span class="sc">|&gt;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">id_node =</span> <span class="fu">row_number</span>())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Definimos nuestro punto de partida en la CDMX, como en la siguiente <img src="https://maps.app.goo.gl/p2SqWT23DZ66zDmX6.png" class="img-fluid" alt="Dirección"> como punto de partida.</p>
<p>Se fijará un presupuesto de tiempo de 30 minutos y se asume como velocidad de conducción de bicilceta media de 4 metros por segundo.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Execution  -----------------------------------------------------------------</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Starting Point </span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># https://maps.app.goo.gl/CnuKBE7yScWgANmp8</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>lat <span class="ot">&lt;-</span> <span class="fl">19.39798481495679</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>lon <span class="ot">&lt;-</span> <span class="sc">-</span><span class="fl">99.1615400498479</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Maximum duration of trajectories in seconds </span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>T_segs <span class="ot">&lt;-</span> <span class="dv">30</span><span class="sc">*</span><span class="dv">60</span> </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>VEL_MPS <span class="ot">&lt;-</span> <span class="dv">4</span> <span class="co"># Average velocity in metter per second</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>TWT_IND <span class="ot">&lt;-</span> <span class="cn">TRUE</span> <span class="co"># Indicator if there are waiting times </span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>TRAFFIC_WT <span class="ot">&lt;-</span> <span class="dv">120</span> <span class="co"># Witing time in seconds </span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>TWT_PROB <span class="ot">&lt;-</span> <span class="fl">0.1</span> <span class="co"># Probability of waiting, wait for green lights</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>POINT_TOLERANCE_M <span class="ot">&lt;-</span> <span class="dv">150</span> <span class="co"># tolerance to find corner from point (mts)</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>ADJ_TOLERANCE_M <span class="ot">&lt;-</span> <span class="dv">3</span> <span class="co"># node-edge adjacency tolerance (mts)</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>ADJE_TOLERANCE_M <span class="ot">&lt;-</span> <span class="dv">3</span> <span class="co"># tolerance for edge-vertex adjacency (mts) </span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>DISPLAY <span class="ot">&lt;-</span> <span class="cn">TRUE</span> <span class="co"># Display map</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>ECHO <span class="ot">&lt;-</span> <span class="cn">FALSE</span> <span class="co"># Print simulation status </span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="ejecución" class="level2">
<h2 class="anchored" data-anchor-id="ejecución">Ejecución</h2>
<p>Ejecutamos las simulación con las parámetros definidos, obteniendo los siguientes resultados:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>isoc <span class="ot">&lt;-</span> <span class="fu">calculate_isochrone</span>(lat,lon,T_segs,shp_streets,corners_sf</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>                         , VEL_MPS</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>                         , TWT_IND, TRAFFIC_WT,TWT_PROB</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>                         , POINT_TOLERANCE_M, ADJ_TOLERANCE_M, ADJE_TOLERANCE_M</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>                         , DISPLAY</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>                         , ECHO</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                         , CRS_MX)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(isoc<span class="sc">$</span>mapa)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="fu">st_write</span>(isoc<span class="sc">$</span>paths_isochrone,<span class="fu">paste0</span>(<span class="st">"./data/sample/"</span>, <span class="st">"/iso_paths.geojson"</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>         ,<span class="at">layer =</span> <span class="st">"iso_paths.geojson"</span> )</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="fu">st_write</span>(isoc<span class="sc">$</span>hull_isochrone,<span class="fu">paste0</span>(<span class="st">"./data/sample/"</span>, <span class="st">"/iso_hull.geojson"</span>)</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>         ,<span class="at">layer =</span> <span class="st">"iso_hull.geojson"</span> )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_final_map.png" class="img-fluid figure-img"></p>
<figcaption>Mapa Resultante</figcaption>
</figure>
</div>
<p>En el mapa anterior podemos ver en color gris claro, las calles de interés (restricción de movimiento) correspondientes a las Alcaldías Miguel Hidalgo, Benito Juárez y Coyoacán. En negro son los caminos alcanzables contenidos en la isócrona, y en color azul la isócrona en sí. El punto de partida esta en color verde y se tienen como objetivo alcanzar el punto azul (oficina).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="./images/iso_se_points.png" class="img-fluid figure-img"></p>
<figcaption>Puntos de origen y destino</figcaption>
</figure>
</div>
<p>Como observamos en la pasada imagen el punto azul esta dentro de nuestra isócrona, permitiendonos concluir que en efecto, podemos realizar nuestro recorrido en al menos 30 min. bajo los supuestos de movilidad que se tomaron.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>